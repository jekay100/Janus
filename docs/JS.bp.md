#JavaScript最佳实践
##目录
* 避免糟粕和鸡肋
* 那些年一起踩过的坑
* 良好的编码习惯
* 更为优雅的方式

##避免糟粕和鸡肋
糟粕：JS的一些存在问题却难以避免的功能特性
鸡肋：JS还存在一些有问题的特性，但我们很容易避过他们

###全局变量

全局变量和全局函数是非常糟糕的。因为在一个页面中包含的所有JavaScript都在同一个域中运行。
所以如果你的代码中声明了全局变量或者全局函数的话，
后面的代码中载入的脚本文件中的同名变量和函数会覆盖掉（overwrite）你的全局变量。

>**解决方式**

>最小全局变量(Minimizing Globals)
JavaScript通过函数管理作用域。在函数内部声明的变量只在这个函数内部，函数外面不可用。
另一方面，全局变量就是在任何函数外面声明的或是未声明直接简单使用的。
```
var globa = {};
var globa = function(){}
```

###作用域

JS与C等其他语言类似，是基于块级（{}），但却没有块级作用域；
块级作用域在于块级内声明的变量，外部是不可见的，
但是在JS中，块级声明的变量在包含此块级的函数的任何位置均是可见的，
这是其他语言是不可想象的
**虽然EC6中会改变此状态，会添加块级变量声明 let **

>**解决方式**

>在每个函数开头声明变量

###保留字

在JS设计之初借鉴的许多语言（C,java,python,ruby等）
所以保留了许多保留字
但这些保留字大多数并没有在语言中用到
他们不能用作参数名，或字面量的属性值

>**解决方式**

>加引号设置参数名，调用的时候用挂号调用法

>当然最佳的方法是不用它

```
var obj = { case: '编写JS最佳实践'};  ==> 这是错误的
var obj = { 'case': '编写JS最佳实践'}; ==> 这是对的
obj.case ==>这是错误的
obj['case'] ==> 这是对的

```

###undefined

undefined 是缺失的成员的值，但它不是个常量，是个全局变量
你可以改变它的值
```
var undefined=8;
(function(window){ 
console.debug(window.undefined); //8
console.debug(undefined); //8
})(window);
```
>**解决方式**

>避免去修改其值

>EC5.1 已修正

```
/** 最优实现 */
(function( window, undefined){
    /* 在这个区域开始你的代码 */
})( window );
```

##可能有坑的方法
>在JS提供的原生方法中，有一些方法可能会与设计该方法的愿意有些偏差，
又或者会造成内存溢出
又或造成JS处理器处理过慢
** 当碰到这些方法的时候，我们的原则是避开他，或者重构其方法 **

###parseInt

parseInt 是将字符串转为整数的方法
它遇到非数字的字符时停止解析
parseInt('16') 与 parseInt('16asshs')会返回相同的结果
它不会提醒我们出现格外的文本
更让我们郁闷的是 parseInt("08") 与 parseInt("09")
当字符串是以08，09开始的时候，会转为8进制计算
所以 parseInt("08") = parseInt("09") = 0; 

>**解决方式**

>针对 0 开头的字符串，使用时加上进制参数  parseInt( "08", 10 )
>EC5.1 已修正

###with

with的本意是想用来快捷的访问对象的属性，
不幸的是它的结果有的时候是不可预料的

```
with( obj ){
    a = b
}
```
它等于下面语句的任意一条
```
a = b;
a = obj.b;
obj.a = obj.b;
obj.a = b;
```

###eval

eval 函数传递字符串给 JavaScript 编译器，并执行其结果；
原意是可以动态的执行JS，
但是它被使用泛滥
```
eval("myValue = myObject." + myKey + ";");

myValue = myObject[myKey];

```
使用eval:
-性能较差，它必须调用编译器来传递其参数，然后执行
-安全问题，因为它会执行传递给它的任何代码，所以容易受各种注入攻击，特别是在来源未知的时候
-不利于调试，eval的参数是动态产生的，调试起来不方便，可读性也较差
** 所以我们的原则是，能不用eval就不用 **

另 timeout函数中的setTimeout()和setInterval()也可以接受字符串参数，然后执行，因此表现跟eval()一样。
应该避免传递字符串

### switch 贯穿

如果你不使用break或return中断流程，则每次贯穿带下一个case;

### continue

continue 语句会跳到循环顶部，如果一段代码通过重构移除continue之后，性能会得到改善

### ++，--，位运算符

看起来都是高大尚的代码，虽然JS都支持，但不易理解
如果不是进行算法编程，建议不要使用它，看着头晕...

### 小数的计算
数值是浮点数，所以...
0.3 - 0.2 != 0.1
 
>**解决方式**

>将小数转为整数计算

### NaN

NaN是比undefined更为特殊的一个值

NaN和undefined一样，是个全局变量而不是常量，它可以被赋值

NaN != NaN，NaN 不等于任何值，包括自己

typeof NaN == "number", 但 NaN 并不是一个数字

isNaN 用来判断是否为NaN； 但令人蛋疼的 isNaN("string") 的返回值是 true

### typeof

typeof 是个运算符， 返回运算数类型的字符串

```
typeof "这是一个字符串"; /*string*/

typeof "98.23"; /*string*/

typeof function{} /* function */

/*好吧，上面这些都是正常的, 让人哭B的下面这些，什么和什么呀· */

typeof [1,2]; /*object*/

typeof null; /*object*/

typeof NaN; /*number*/

```
>**解决方式**

>需要自定文件类型方法，常用有 isArray, isFunction 等
>Object.prototype.toString.apply( t )

### for in

for in 语句可以用来遍历对象的所有属性的名字，
糟糕的是它也可以遍历所有从原型链中继承而来的成员元素，这并不是我们想要的

>**解决方式**

```
for( var item in t ){
    if( t.hasOwnProperty( item ) ){
         
    }
}
```

## 良好的编码习惯

### 补全代码块

JS 是基于块级的编码，
但 if, for 简单语句也支持无块级标签
```
if( true ) alert(1);

if( true ){
    alert(1);
}
```

但我们期望if,for或其他时候需要块级的时候用{}围起来，增强代码的可读性，即使再简单的代码

```
if( true )
alert(1);
alert(2);

/*我们不明白, 这样的代码表示的是什么意思*/
if( true ){
    alert(1);
    alert(2);
}
/*还是*/
if( true ){
    alert(1);
}
alert(2);

```

### 结尾“;"

JS解析器解析JS代码时，是由从上至下，逐行解析，
如果行尾或下行首没有特定的连接运算符标明该行尚未结束
那么JS的解析器就会认为该行已经结束，自动会在末尾加上";"等待编译

```
 return 
 {
    a: 1
 }
 
```

会被解析成

```
 return ;
 {
    a: 1
 };
 
```

而不是你想表达的

```
return { a: 1 };

```

养好良好的编码习惯，主动在代码结束的时候加上";"表明，既增加代码的可读性，
又可以减少一些看起来莫名其妙的错误，而且还可以一定程度上提高编译器的工作效率

### == 与 ===

=== 才是真正意义上的比较

== 会在执行比较钱进行类型转换（原则是转为数字进行比较）

所以才会出现

[] == ![] 是成立的···

所以编程的时候，尽量使用 ===，
而需要转类型判断的时候 使用 == （经常使用的场景是判断布尔值）

### use strict

使用严格模式编程，会让你减少很多编程意外风险
其一：如果在语法检测时发现语法问题，则整个代码块失效，并导致一个语法异常。
其二：如果在运行期出现了违反严格模式的代码，则抛出执行异常。
注：经过测试IE6,7,8,9均不支持严格模式。

### "" and ''

建议在JS中使用单引号，因为HTML使用双引号，也可以和JSON区分
只是单纯习惯性问题～


### 外部JS引入，放在页面底部

外部JS，比如第三方引入，对具体业务没有帮助，建议放在页面底部
避免影响页面正常载入

### delete

不要直接使用 delete 来直接删除数组的某一项
因为它只是软删除，只是删掉其值，
但没有更新索引值，所以数组长度不变

### var

在给第一次给一个变量赋值的时候，不要忘记 var;
如果忘记了，改变量就会变成全局变量...

### arguments

arguments 是个类数组，但不是一个数组
所以如果要对 arguments 进行深层次处理，
加以先转成数组进行操作
```
    Array.prototype.slice.call( arguments );
```

### switch/case 

如果有大量的if/else建议使用 switch/case
但 case 多余 10个 那就要慎重了··

### 特性检测而非浏览器检测

一些代码是写来发现浏览器版本并基于用户正使用的客户端的对其执行不同行为。
这个，总的来说，是一个非常糟的实践。
更好的方法是使用特性检测，
在使 用一个老浏览器可能不支持的高级的特性之前，
首先检测（浏览器的）是否有这个功能或特性，然后使用它。
这单独检测浏览器版本来得更好，即使你知道它的性能

### 使用方括号记法
```
MyObject.property
MyObject["property"]
```
因为保留字会带.字符串等原因，更建议使用第二种表示方法

### 请不要使用 href="#"

如果你的方法是 链接的onclick触发的事件，请加上 return false/true， 就可以防止 href 触发;
避免 href="#" 使用，防止页面跳动

### 使用正确的 \<script\> 标签

不要在 \<script\> 中的使用LANGUAGE 属性

## 更为优雅的方式

> #且听下回分解